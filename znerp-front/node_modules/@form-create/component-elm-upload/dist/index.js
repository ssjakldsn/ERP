/*!
 * @form-create/component-elm-upload v3.2.7
 * (c) 2018-2024 xaboy
 * Github https://github.com/xaboy/form-create with upload
 * Released under the MIT License.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.FcUpload = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function toArray(value) {
    return Array.isArray(value) ? value : [null, undefined, ''].indexOf(value) > -1 ? [] : [value];
  }

  function getSlot(slots, exclude) {
    return Object.keys(slots).reduce(function (lst, name) {
      if (!exclude || exclude.indexOf(name) === -1) {
        lst.push(slots[name]);
      }

      return lst;
    }, []);
  }

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = "._fc-upload{width:100%}._fc-exceed .el-upload{display:none}.el-upload-list.is-disabled .el-upload{cursor:not-allowed!important}";
  styleInject(css_248z);

  var script = {
    name: 'IconUpload'
  };

  var _hoisted_1 = {
    "class": "icon",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg"
  };

  var _hoisted_2 = /*#__PURE__*/vue.createElementVNode("path", {
    fill: "currentColor",
    d: "M160 832h704a32 32 0 110 64H160a32 32 0 110-64zm384-578.304V704h-64V247.296L237.248 490.048 192 444.8 508.8 128l316.8 316.8-45.312 45.248L544 253.696z"
  }, null, -1);

  var _hoisted_3 = [_hoisted_2];
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", _hoisted_1, _hoisted_3);
  }

  script.render = render;

  function parseFile(file, i) {
    return {
      url: file,
      name: getFileName(file),
      uid: i
    };
  }

  function getFileName(file) {
    return ('' + file).split('/').pop();
  }

  var NAME = 'fcUpload';
  var Upload = vue.defineComponent({
    name: NAME,
    inheritAttrs: false,
    formCreateParser: {
      toFormValue: function toFormValue(value) {
        return toArray(value);
      },
      toValue: function toValue(formValue, ctx) {
        return ctx.prop.props.limit === 1 ? formValue[0] || '' : formValue;
      }
    },
    props: {
      previewMask: undefined,
      onPreview: Function,
      modalTitle: String,
      listType: String,
      modelValue: [Array, String]
    },
    emits: ['update:modelValue', 'change', 'remove', 'fc.el'],
    data: function data() {
      return {
        previewVisible: false,
        previewImage: '',
        fileList: []
      };
    },
    created: function created() {
      this.fileList = toArray(this.modelValue).map(parseFile);
    },
    watch: {
      modelValue: function modelValue(n) {
        this.fileList = toArray(n).map(parseFile);
      }
    },
    methods: {
      handlePreview: function handlePreview(file) {
        if (this.onPreview) {
          this.onPreview.apply(this, arguments);
        } else {
          if ('text' === this.listType) {
            window.open(file.url);
          } else {
            this.previewImage = file.url;
            this.previewVisible = true;
          }
        }
      },
      update: function update(fileList) {
        var files = fileList.map(function (file) {
          return file.url;
        }).filter(function (url) {
          return url !== undefined;
        });
        this.$emit('update:modelValue', files);
      },
      handleCancel: function handleCancel() {
        this.previewVisible = false;
      },
      handleChange: function handleChange(file, fileList) {
        this.$emit.apply(this, ['change'].concat(Array.prototype.slice.call(arguments)));

        if (file.status === 'success') {
          this.update(fileList);
        }
      },
      handleRemove: function handleRemove(file, fileList) {
        this.$emit.apply(this, ['remove'].concat(Array.prototype.slice.call(arguments)));
        this.update(fileList);
      }
    },
    render: function render() {
      var _this$$slots$default,
          _this$$slots,
          _this = this;

      var len = toArray(this.modelValue).length;
      return vue.createVNode("div", {
        "class": "_fc-upload"
      }, [vue.createVNode(vue.resolveComponent("ElUpload"), vue.mergeProps({
        "key": len
      }, this.$attrs, {
        "list-type": this.listType || 'picture-card',
        "class": {
          '_fc-exceed': this.$attrs.limit ? this.$attrs.limit <= len : false
        },
        "onPreview": this.handlePreview,
        "onChange": this.handleChange,
        "onRemove": this.handleRemove,
        "fileList": this.fileList,
        "ref": "upload"
      }), _objectSpread2({
        "default": function _default() {
          return [(_this$$slots$default = (_this$$slots = _this.$slots)["default"]) !== null && _this$$slots$default !== void 0 && _this$$slots$default.call(_this$$slots) || ['text', 'picture'].indexOf(_this.listType) === -1 ? vue.createVNode(vue.resolveComponent("ElIcon"), null, {
            "default": function _default() {
              return [vue.createVNode(script, null, null)];
            }
          }) : vue.createVNode(vue.resolveComponent("ElButton"), {
            "type": "primary"
          }, {
            "default": function _default() {
              return [vue.createTextVNode("\u70B9\u51FB\u4E0A\u4F20")];
            }
          })];
        }
      }, getSlot(this.$slots, ['default']))), vue.createVNode(vue.resolveComponent("ElDialog"), {
        "appendToBody": true,
        "modal": this.previewMask,
        "title": this.modalTitle,
        "modelValue": this.previewVisible,
        "onClose": this.handleCancel
      }, {
        "default": function _default() {
          return [vue.createVNode("img", {
            "style": "width: 100%",
            "src": _this.previewImage
          }, null)];
        }
      })]);
    },
    mounted: function mounted() {
      this.$emit('fc.el', this.$refs.upload);
    }
  });

  exports["default"] = Upload;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
